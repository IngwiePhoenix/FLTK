<HTML>
<HEAD>
	<TITLE>Fl_Input</TITLE>
</HEAD>
<BODY>

<!-- NEW PAGE -->

<H2><A name=Fl_Input>class Fl_Input</A></H2>

<HR>

<H3>Class Hierarchy</H3>

<UL><PRE>
<A href=Fl_Input_.html#Fl_Input_>Fl_Input_</A>
   |
   +----<B>Fl_Input</B>
           |
           +----<A href="Fl_File_Input.html">Fl_File_Input</A>, <A href=Fl_Float_Input.html#Fl_Float_Input>Fl_Float_Input</A>,
	        <A href=Fl_Int_Input.html#Fl_Int_Input>Fl_Int_Input</A>, <A href=Fl_Multiline_Input.html#Fl_Multiline_Input>Fl_Multiline_Input</A>,
		<A href=Fl_Output.html#Fl_Output>Fl_Output</A>, <A href=Fl_Secret_Input.html#Fl_Secret_Input>Fl_Secret_Input</A>
</PRE></UL>

<H3>Include Files</H3>

<UL><PRE>
#include &lt;FL/Fl_Input.H&gt;
</PRE></UL>

<H3>Description</H3>

<P>This is the FLTK text input widget. It displays a single line
of text and lets the user edit it. Normally it is drawn with an
inset box and a white background. The text may contain any
characters (even 0), and will correctly display anything, using
^X notation for unprintable control characters and \nnn notation
for unprintable characters with the high bit set. It assumes the
font can draw any characters in the ISO-8859-1 character set.</P>

<CENTER><TABLE border=1 WIDTH=90% summary="Fl_Input keyboard and mouse bindings.">

<TR><TD WIDTH=200><B>Mouse button 1</B></TD><TD>Moves the cursor to
 this point. Drag selects characters.  Double click selects words.
 Triple click selects all text.  Shift+click extends the selection.
 When you select text it is automatically copied to the clipboard.
</TD></TR>

<TR><TD><B>Mouse button 2</B></TD><TD>Insert the clipboard at
the point clicked.  You can also select a region and replace it with the
clipboard by selecting the region with mouse button 2.
</TD></TR>

<TR><TD><B>Mouse button 3</B></TD><TD>Currently acts like button 1.</TD></TR>

<TR><TD><B>Backspace</B></TD><TD>Deletes one character to the left, or
deletes the selected region.</TD></TR>
<TR><TD><B>Enter</B></TD><TD>May cause the callback, see when().</TD></TR>
<TR><TD><B>^A or Home</B></TD><TD>Go to start of line.</TD></TR>
<TR><TD><B>^B or Left</B></TD><TD>Move left</TD></TR>
<TR><TD><B>^C</B></TD><TD>Copy the selection to the clipboard</TD></TR>
<TR><TD><B>^D or Delete</B></TD><TD>Deletes one character to the right
or deletes the selected region.</TD></TR>
<TR><TD><B>^E or End</B></TD><TD>Go to the end of line.</TD></TR>
<TR><TD><B>^F or Right</B></TD><TD>Move right</TD></TR>
<TR><TD><B>^K</B></TD><TD>Delete to the end of line (next \n character)
or deletes a single \n character.  These deletions are all concatenated
into the clipboard.</TD></TR>
<TR><TD><B>^N or Down</B></TD><TD>Move down (for Fl_Multiline_Input
only, otherwise it moves to the next input field).</TD></TR>
<TR><TD><B>^P or Up</B></TD><TD>Move up (for Fl_Multiline_Input only,
otherwise it moves to the previous input field).</TD></TR>
<TR><TD><B>^U</B></TD><TD>Delete everything.</TD></TR>
<TR><TD><B>^V or ^Y</B></TD><TD>Paste the clipboard</TD></TR>
<TR><TD><B>^X or ^W</B></TD><TD>Copy the region to the clipboard and
delete it.</TD></TR>
<TR><TD><B>^Z or ^_</B></TD><TD>Undo.  This is a single-level undo
mechanism, but all adjacent deletions and insertions are concatenated
into a single &quot;undo&quot;.  Often this will undo a lot more than you
expected.</TD></TR>
<TR><TD><B>Shift+move</B></TD><TD>Move the cursor but also extend the
selection.</TD></TR>

<TR><TD><B>RightCtrl or
<BR>Compose</B></TD><TD><a name=compose>Start</A>
a <A href="events.html#compose">compose-character</A>
sequence.  The next one or two keys typed define the character to
insert (see table that follows.)

<p>For instance, to type "á" type [compose][a]['] or [compose]['][a].

<P>The character "nbsp" (non-breaking space) is typed by using
[compose][space].

<P>The single-character sequences may be followed by a space if
necessary to remove ambiguity.  For instance, if you really want to
type "ª~" rather than "ã" you must type [compose][a][space][~].

<p>The same key may be used to "quote" control characters into the
text.  If you need a <tt>^Q</tt> character you can get one by typing
[compose][Control+Q].

<p>X may have a key on the keyboard
defined as <tt>XK_Multi_key</tt>.  If so this key may be used as well
as the right-hand control key.  You can set this up with the program
<tt>xmodmap</tt>.

<p>If your keyboard is set to support a foreign language you should
also be able to type "dead key" prefix characters.  On X you will
actually be able to see what dead key you typed, and if you then move
the cursor without completing the sequence the accent will remain
inserted.</TD></TR>
</TABLE></CENTER>

<!-- NEW PAGE -->
<center><table border=1 summary="Character Composition Table">
<caption align="top">Character Composition Table</caption>
<tr>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>
	<th>Keys</th><th>Char</th>

</tr><tr>
	<td align=center><TT>sp</TT></td><td align=center><small>nbsp</small></td>
	<td align=center><TT>*</tt></td><td align=center>°</td>
	<td align=center><TT>` A</tt></td><td align=center>À</td>
	<td align=center><TT>D -</tt></td><td align=center>Ð</td>
	<td align=center><TT>` a</tt></td><td align=center>à</td>
	<td align=center><TT>d -</tt></td><td align=center>ð</td>
</tr><tr>
	<td align=center><TT>!</tt></td><td align=center>¡</td>
	<td align=center><TT>+ -</tt></td><td align=center>±</td>
	<td align=center><TT>' A</tt></td><td align=center>Á</td>
	<td align=center><TT>~ N</tt></td><td align=center>Ñ</td>
	<td align=center><TT>' a</tt></td><td align=center>á</td>
	<td align=center><TT>~ n</tt></td><td align=center>ñ</td>
</tr><tr>
	<td align=center><TT>%</tt></td><td align=center>¢</td>
	<td align=center><TT>2</tt></td><td align=center>²</td>
	<td align=center><TT>A ^</tt></td><td align=center>Â</td>
	<td align=center><TT>` O</tt></td><td align=center>Ò</td>
	<td align=center><TT>^ a</tt></td><td align=center>â</td>
	<td align=center><TT>` o</tt></td><td align=center>ò</td>
</tr><tr>
	<td align=center><TT>#</tt></td><td align=center>£</td>
	<td align=center><TT>3</tt></td><td align=center>³</td>
	<td align=center><TT>~ A</tt></td><td align=center>Ã</td>
	<td align=center><TT>' O</tt></td><td align=center>Ó</td>
	<td align=center><TT>~ a</tt></td><td align=center>ã</td>
	<td align=center><TT>' o</tt></td><td align=center>ó</td>
</tr><tr>
	<td align=center><TT>$</tt></td><td align=center>¤</td>
	<td align=center><TT>'</tt></td><td align=center>´</td>
	<td align=center><TT>: A</tt></td><td align=center>Ä</td>
	<td align=center><TT>^ O</tt></td><td align=center>Ô</td>
	<td align=center><TT>: a</tt></td><td align=center>ä</td>
	<td align=center><TT>^ o</tt></td><td align=center>ô</td>
</tr><tr>
	<td align=center><TT>y =</tt></td><td align=center>¥</td>
	<td align=center><TT>u</tt></td><td align=center>µ</td>
	<td align=center><TT>* A</tt></td><td align=center>Å</td>
	<td align=center><TT>~ O</tt></td><td align=center>Õ</td>
	<td align=center><TT>* a</tt></td><td align=center>å</td>
	<td align=center><TT>~ o</tt></td><td align=center>õ</td>
</tr><tr>
	<td align=center><TT>|</tt></td><td align=center>¦</td>
	<td align=center><TT>p</tt></td><td align=center>¶</td>
	<td align=center><TT>A E</tt></td><td align=center>Æ</td>
	<td align=center><TT>: O</tt></td><td align=center>Ö</td>
	<td align=center><TT>a e</tt></td><td align=center>æ</td>
	<td align=center><TT>: o</tt></td><td align=center>ö</td>
</tr><tr>
	<td align=center><TT>&amp;</tt></td><td align=center>§</td>
	<td align=center><TT>.</tt></td><td align=center>·</td>
	<td align=center><TT>, C</tt></td><td align=center>Ç</td>
	<td align=center><TT>x</tt></td><td align=center>×</td>
	<td align=center><TT>, c</tt></td><td align=center>ç</td>
	<td align=center><TT>- :</tt></td><td align=center>÷</td>
</tr><tr>
	<td align=center><TT>:</tt></td><td align=center>¨</td>
	<td align=center><TT>,</tt></td><td align=center>¸</td>
	<td align=center><TT>E `</tt></td><td align=center>È</td>
	<td align=center><TT>O /</tt></td><td align=center>Ø</td>
	<td align=center><TT>` e</tt></td><td align=center>è</td>
	<td align=center><TT>o /</tt></td><td align=center>ø</td>
</tr><tr>
	<td align=center><TT>c</tt></td><td align=center>©</td>
	<td align=center><TT>1</tt></td><td align=center>¹</td>
	<td align=center><TT>' E</tt></td><td align=center>É</td>
	<td align=center><TT>` U</tt></td><td align=center>Ù</td>
	<td align=center><TT>' e</tt></td><td align=center>é</td>
	<td align=center><TT>` u</tt></td><td align=center>ù</td>
</tr><tr>
	<td align=center><TT>a</tt></td><td align=center>ª</td>
	<td align=center><TT>o</tt></td><td align=center>º</td>
	<td align=center><TT>^ E</tt></td><td align=center>Ê</td>
	<td align=center><TT>' U</tt></td><td align=center>Ú</td>
	<td align=center><TT>^ e</tt></td><td align=center>ê</td>
	<td align=center><TT>' u</tt></td><td align=center>ú</td>
</tr><tr>
	<td align=center><TT>&lt; &lt;</tt></td><td align=center>«</td>
	<td align=center><TT>&gt; &gt;</tt></td><td align=center>»</td>
	<td align=center><TT>: E</tt></td><td align=center>Ë</td>
	<td align=center><TT>^ U</tt></td><td align=center>Û</td>
	<td align=center><TT>: e</tt></td><td align=center>ë</td>
	<td align=center><TT>^ u</tt></td><td align=center>û</td>
</tr><tr>
	<td align=center><TT>~</tt></td><td align=center>¬</td>
	<td align=center><TT>1 4</tt></td><td align=center>¼</td>
	<td align=center><TT>` I</tt></td><td align=center>Ì</td>
	<td align=center><TT>: U</tt></td><td align=center>Ü</td>
	<td align=center><TT>` i</tt></td><td align=center>ì</td>
	<td align=center><TT>: u</tt></td><td align=center>ü</td>
</tr><tr>
	<td align=center><TT>-</tt></td><td align=center>­</td>
	<td align=center><TT>1 2</tt></td><td align=center>½</td>
	<td align=center><TT>' I</tt></td><td align=center>Í</td>
	<td align=center><TT>' Y</tt></td><td align=center>Ý</td>
	<td align=center><TT>' i</tt></td><td align=center>í</td>
	<td align=center><TT>' y</tt></td><td align=center>ý</td>
</tr><tr>
	<td align=center><TT>r</tt></td><td align=center>®</td>
	<td align=center><TT>3 4</tt></td><td align=center>¾</td>
	<td align=center><TT>^ I</tt></td><td align=center>Î</td>
	<td align=center><TT>T H</tt></td><td align=center>Þ</td>
	<td align=center><TT>^ i</tt></td><td align=center>î</td>
	<td align=center><TT>t h</tt></td><td align=center>þ</td>
</tr><tr>
	<td align=center><TT>_</tt></td><td align=center>¯</td>
	<td align=center><TT>?</tt></td><td align=center>¿</td>
	<td align=center><TT>: I</tt></td><td align=center>Ï</td>
	<td align=center><TT>s s</tt></td><td align=center>ß</td>
	<td align=center><TT>: i</tt></td><td align=center>ï</td>
	<td align=center><TT>: y</tt></td><td align=center>ÿ</td>
</tr>
</table></center>
<H3>Methods</H3>
<CENTER>
<TABLE width=90% summary="Fl_Input methods.">
<TR><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.Fl_Input>Fl_Input</A></LI>
<LI><A href=#Fl_Input.~Fl_Input>~Fl_Input</A></LI>
<LI><A href=#Fl_Input.cursor_color>cursor_color</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.index>index</A></LI>
<LI><A href=#Fl_Input.size>size</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.static_value>static_value</A></LI>
<LI><A href=#Fl_Input.textcolor>textcolor</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.textfont>textfont</A></LI>
<LI><A href=#Fl_Input.textsize>textsize</A></LI>
</UL>
</TD><TD align=left valign=top>
<UL>
<LI><A href=#Fl_Input.value>value</A></LI>
<LI><A href=#Fl_Input.when>when</A></LI>
</UL>
</TD></TR>
</TABLE>
</CENTER>

<H4><A name="Fl_Input.Fl_Input">Fl_Input::Fl_Input(int x, int y, int w,
int h, const char *label = 0)</A></H4>

<P>Creates a new <TT>Fl_Input</TT> widget using the given position, size,
and label string. The default boxtype is <TT>FL_DOWN_BOX</TT>.

<H4><A name="Fl_Input.~Fl_Input">virtual Fl_Input::~Fl_Input()</A></H4>

<P>Destroys the widget and any value associated with it.

<H4><A name="Fl_Input.value">const char *Fl_Input::value() const
<BR>int Fl_Input::value(const char*)
<BR>int Fl_Input::value(const char*, int)</A></H4>

<P>The first form returns the current value, which is a pointer
to the internal buffer and is valid only until the next event is
handled.

<P>The second two forms change the text and set the mark and the
point to the end of it. The string is copied to the internal
buffer. Passing <TT>NULL</TT> is the same as &quot;&quot;. 
This returns non-zero if the new value is different than the
current one.  You can use the second version to directly set the
length if you know it already or want to put nul's in the
text.</P>

<H4><A name="Fl_Input.static_value">int Fl_Input::static_value(const
char*)
<BR>int Fl_Input::static_value(const char*, int)</A></H4>

<P>Change the text and set the mark and the point to the end of
it. The string is <I>not</I> copied. If the user edits the
string it is copied to the internal buffer then. This can save a
great deal of time and memory if your program is rapidly
changing the values of text fields, but this will only work if
the passed string remains unchanged until either the
<TT>Fl_Input</TT> is destroyed or <TT>value()</TT> is called
again.

<H4><A name="Fl_Input.size">int Fl_Input::size() const</A></H4>

<P>Returns the number of characters in <TT>value()</TT>. This
may be greater than <TT>strlen(value())</TT> if there are nul
characters in it.

<H4><A name="Fl_Input.index">char Fl_Input::index(int) const</A></H4>

<P>Same as <TT>value()[n]</TT>, but may be faster in plausible
implementations. No bounds checking is done.

<H4><A name="Fl_Input.when">Fl_When Fl_Widget::when() const
<BR>void Fl_Widget::when(Fl_When)</A></H4>

<P>Controls when callbacks are done. The following values are useful,
the default value is <TT>FL_WHEN_RELEASE</TT>:

<UL>

	<LI><TT>0</TT>: The callback is not done, but
	<TT>changed()</TT> is turned on.</LI>

	<LI><TT>FL_WHEN_CHANGED</TT>: The callback is done each
	time the text is changed by the user.</LI>

	<LI><TT>FL_WHEN_RELEASE</TT>: The callback will be done
	when this widget loses the focus, including when the
	window is unmapped. This is a useful value for text
	fields in a panel where doing the callback on every
	change is wasteful. However the callback will also
	happen if the mouse is moved out of the window, which
	means it should not do anything visible (like pop up an
	error message). You might do better setting this to
	zero, and scanning all the items for <TT>changed()</TT>
	when the OK button on a panel is pressed.</LI>

	<LI><TT>FL_WHEN_ENTER_KEY</TT>: If the user types the
	Enter key, the entire text is selected, and the callback
	is done if the text has changed. Normally the Enter key
	will navigate to the next field (or insert a newline for
	a <TT>Fl_Mulitline_Input</TT>), this changes the
	behavior.</LI>

	<LI><TT>FL_WHEN_ENTER_KEY|FL_WHEN_NOT_CHANGED</TT>: The
	Enter key will do the callback even if the text has not
	changed. Useful for command fields.</LI>

</UL>

<H4><A name="Fl_Input.textcolor">Fl_Color Fl_Input::textcolor() const
<BR>void Fl_Input::textcolor(Fl_Color)</A></H4>

<P>Gets or sets the color of the text in the input field.

<H4><A name="Fl_Input.textfont">Fl_Font Fl_Input::textfont() const
<BR>void Fl_Input::textfont(Fl_Font)</A></H4>

<P>Gets or sets the font of the text in the input field.

<H4><A name="Fl_Input.textsize">uchar Fl_Input::textsize() const
<BR>void Fl_Input::textsize(uchar)</A></H4>

<P>Gets or sets the size of the text in the input field.

<H4><A name="Fl_Input.cursor_color">Fl_Color Fl_Input::cursor_color()
const
<BR>void Fl_Input::cursor_color(Fl_Color)</A></H4>

<P>Get or set the color of the cursor.  This is black by default.

</BODY>
</HTML>
